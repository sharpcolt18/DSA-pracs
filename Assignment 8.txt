<!-- Assignment 8 -->
#include <iostream>
#include <string>
using namespace std;

struct Node {
    char data;
    Node* next;
};

class Stack {
private:
    Node* top;

public:
    string exp;

    Stack() {
        top = nullptr;
        cout << "Enter the expression to be converted: ";
        cin >> exp;
    }

    ~Stack() {
        while (!isempty()) {
            Pop();
        }
    }

    void Push(char c) {
        Node* newnode = new Node;
        newnode->data = c;
        newnode->next = top;
        top = newnode;
    }

    char Pop() {
        if (isempty()) return '\0';
        char c = top->data;
        Node* temp = top;
        top = top->next;
        delete temp;
        return c;
    }

    bool isempty() {
        return (top == nullptr);
    }

    int priority(char op) {
        if (op == '*' || op == '/') return 2;
        if (op == '+' || op == '-') return 1;
        return 0;
    }

    string reverseFlip(const string& expr) {
        string rev = "";
        for (int i = expr.length() - 1; i >= 0; i--) {
            char c = expr[i];
            if (c == '(') rev += ')';
            else if (c == ')') rev += '(';
            else if (c == '{') rev += '}';
            else if (c == '}') rev += '{';
            else if (c == '[') rev += ']';
            else if (c == ']') rev += '[';
            else rev += c;
        }
        return rev;
    }

    string reverseString(const string& expr) {
        return string(expr.rbegin(), expr.rend());
    }

    string infixToPostfix(const string& expr) {
        string output = "";
        for (char c : expr) {
            if (isalnum(c)) {
                output += c;
            }
            else if (c == '(' || c == '{' || c == '[') {
                Push(c);
            }
            else if (c == '+' || c == '-' || c == '*' || c == '/') {
                while (!isempty() && priority(c) <= priority(top->data)) {
                    if (top->data == '(' || top->data == '{' || top->data == '[') break;
                    output += Pop();
                }
                Push(c);
            }
            else if (c == ')' || c == '}' || c == ']') {
                while (!isempty() && !(top->data == '(' || top->data == '{' || top->data == '[')) {
                    output += Pop();
                }
                if (!isempty()) {
                    Pop(); // remove opening bracket
                }
                else {
                    cout << "\nError: Unbalanced expression.";
                }
            }
            else {
                cout << "Invalid character: " << c << endl;
                return "";
            }
        }
        while (!isempty()) {
            if (top->data == '(' || top->data == '{' || top->data == '[') {
                cout << "\nError: Unbalanced expression.";
                return "";
            }
            output += Pop();
        }
        return output;
    }

    string infixToPrefix(const string& expr) {
        string result = reverseFlip(expr);
        result = infixToPostfix(result);
        result = reverseString(result);
        return result;
    }
};

int main() {
    Stack s;
    cout << "Postfix expression: " << s.infixToPostfix(s.exp) << endl;
    cout << "Prefix expression: " << s.infixToPrefix(s.exp) << endl;
    return 0;
}